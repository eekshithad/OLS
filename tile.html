<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>3D Buildings + Capsules/Wedges (fixed)</title>
  <link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
  <style>
    body { margin:0; padding:0; font-family: Arial, Helvetica, sans-serif; }
    #map { height: 100vh; width: 100vw; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 9999;
      background: white;
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 0 5px #333;
      max-width: 420px;
    }
    #controls button, #controls label { display: inline-block; margin: 4px 6px 4px 0; cursor: pointer; vertical-align: middle; }
    #toggles { margin-top: 6px; display:flex; flex-wrap:wrap; gap:6px; }
    .toggle-label { font-size:13px; }
  </style>
</head>
<body>
<div id="controls">
  <label class="toggle-label">
    <input type="checkbox" id="toggleJSON"> Load geojson
  </label>
  <div id="toggles">
    <label class="toggle-label"><input type="checkbox" id="t_rect" checked> Runway</label>
    <label class="toggle-label"><input type="checkbox" id="t_app" checked> Approach </label>
    <label class="toggle-label"><input type="checkbox" id="t_take" checked> Takeoff </label>
    <label><input type="checkbox" id="t_dc" checked> Transitional 1</label>
    <label><input type="checkbox" id="t_ab" checked> Transitional 2</label>
    <label><input type="checkbox" id="t_conical" checked> Conical</label>
    <label><input type="checkbox" id="t_ihs" checked> Inner Horizontal Surface</label>
    <label><input type="checkbox" id="t_ohs" checked> Outer Horizontal Surface</label>
  </div>
</div>
<div id="map"></div>
<script>
const R = 6371000;
const toRad = d => d * Math.PI/180;
const toDeg = r => r * 180/Math.PI;
function distance(a,b){
  const φ1 = toRad(a[1]), φ2 = toRad(b[1]);
  const Δφ = toRad(b[1]-a[1]), Δλ = toRad(b[0]-a[0]);
  const aa = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
  const c = 2*Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa));
  return R*c;
}
function bearing(a,b){
  const φ1 = toRad(a[1]), φ2 = toRad(b[1]);
  const λ1 = toRad(a[0]), λ2 = toRad(b[0]);
  const y = Math.sin(λ2-λ1) * Math.cos(φ2);
  const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
  return (toDeg(Math.atan2(y,x)) + 360) % 360;
}
function midpoint(a,b){ return [(a[0]+b[0])/2, (a[1]+b[1])/2]; }
function destPoint([lon, lat], bearingDeg, distanceM){
  const φ1 = toRad(lat);
  const λ1 = toRad(lon);
  const θ = toRad(bearingDeg);
  const δ = distanceM / R;
  const φ2 = Math.asin(Math.sin(φ1)*Math.cos(δ) + Math.cos(φ1)*Math.sin(δ)*Math.cos(θ));
  const λ2 = λ1 + Math.atan2(Math.sin(θ)*Math.sin(δ)*Math.cos(φ1), Math.cos(δ)-Math.sin(φ1)*Math.sin(φ2));
  return [toDeg(λ2), toDeg(φ2)];
}
const A = [77.08600, 28.56720];
const B = [77.12115, 28.55910];
const C = [77.12100, 28.55870];
const D = [77.08575, 28.56680];
const centerA = midpoint(A, D);
const centerB = midpoint(C, B);
const runwayCenter = midpoint(centerA, centerB);
const rectCoords = [A, B, C, D, A];
const { A_ext, B_ext, C_ext, D_ext } = makeOuterRunwayRect(A, B, C, D);
const outerRect = [A_ext, B_ext, C_ext, D_ext, A_ext];
const innerHorizRadius = 4000.0;
const innerHorizHeight = 45.0;
const conicalOuterRadius = 6000.0;
const conicalHeight = 200.0;
const conicalCapsule = buildConicalCapsule(
  centerA, 
  centerB, 
  innerHorizRadius, 
  conicalOuterRadius, 
  innerHorizHeight, 
  conicalHeight
);
let ml = null;            
let proc = null;             
let buildingsData = null;    
let bldSourceAdded = false;  
function offsetPoint(pt, bearingDeg, distM) {
  return destPoint(pt, bearingDeg, distM);
}
function makeOuterRunwayRect(A, B, C, D, offsetAB_CD = 140, offsetBC_AD = 60) {
  const centroid = [
    (A[0] + B[0] + C[0] + D[0]) / 4,
    (A[1] + B[1] + C[1] + D[1]) / 4
  ];
  const brAB = bearing(A, B);
  const brBC = bearing(B, C);
  const brCD = bearing(C, D);
  const brDA = bearing(D, A);
  let nAB = (brAB + 90) % 360;
  let nBC = (brBC + 90) % 360;
  let nCD = (brCD + 90) % 360;
  let nDA = (brDA + 90) % 360;
  nAB = correctNormal(nAB, centroid, midpoint(A, B));
  nBC = correctNormal(nBC, centroid, midpoint(B, C));
  nCD = correctNormal(nCD, centroid, midpoint(C, D));
  nDA = correctNormal(nDA, centroid, midpoint(D, A));
  const A_ext = destPoint(
    destPoint(A, nDA, offsetBC_AD),
    nAB, offsetAB_CD
  );
  const B_ext = destPoint(
    destPoint(B, nAB, offsetAB_CD),
    nBC, offsetBC_AD
  );
  const C_ext = destPoint(
    destPoint(C, nBC, offsetBC_AD),
    nCD, offsetAB_CD
  );
  const D_ext = destPoint(
    destPoint(D, nCD, offsetAB_CD),
    nDA, offsetBC_AD
  );
  return { A_ext, B_ext, C_ext, D_ext };
}
function metersToLatLonOffset(dx, dy, lat) {
  const dLat = dy / 111320; // meters per degree latitude
  const dLon = dx / (111320 * Math.cos(lat * Math.PI / 180)); // meters per degree longitude
  return [dLon, dLat];
}
function correctNormal(outward, centroid, midpoint) {
  const dirToCenter = bearing(midpoint, centroid);
  const diff = Math.abs(((outward - dirToCenter + 540) % 360) - 180);
  return diff > 90 ? outward : (outward + 180) % 360;
}
const defaults = { bandCount: 360, wedgeLength: 15700, angleWidthDeg: 3 };
function expandSideEndpoints(side) {
  const sb = bearing(side.a, side.b);
  const expandedA = destPoint(side.a, sb + 180, 5);
  const expandedB = destPoint(side.b, sb, 5);
  return { expandedA, expandedB, sideBearing: sb };
}
function outwardNormalBearingForExpanded(expanded, centroid) {
  const centerLineStart = midpoint(expanded.expandedA, expanded.expandedB);
  const nR = (expanded.sideBearing + 90) % 360;
  const nL = (expanded.sideBearing + 270) % 360;
  const candR = destPoint(centerLineStart, nR, 10);
  const candL = destPoint(centerLineStart, nL, 10);
  const dR = distance(centroid, candR);
  const dL = distance(centroid, candL);
  return dR > dL ? nR : nL;
}
function generateWedgeBandsForExpanded(exp, slopeDeg, color, centroid) {
  const baseWidth = distance(exp.expandedA, exp.expandedB);
  const bands = [];
  const sideBearing = bearing(exp.expandedA, exp.expandedB);
  const outward = outwardNormalBearingForExpanded(exp, centroid);
  const nSeg = defaults.bandCount;
  const segLen = defaults.wedgeLength / nSeg;
  const angleWidthRad = toRad(defaults.angleWidthDeg);
  for (let i = 0; i < nSeg; i++) {
    const d0 = i * segLen;
    const d1 = (i + 1) * segLen;
    const A0 = destPoint(exp.expandedA, outward, d0);
    const B0 = destPoint(exp.expandedB, outward, d0);
    const A1 = destPoint(exp.expandedA, outward, d1);
    const B1 = destPoint(exp.expandedB, outward, d1);
    const expand0 = d0 * Math.tan(angleWidthRad);
    const expand1 = d1 * Math.tan(angleWidthRad);
    const left0  = destPoint(A0, sideBearing + 180, expand0);
    const right0 = destPoint(B0, sideBearing,       expand0);
    const left1  = destPoint(A1, sideBearing + 180, expand1);
    const right1 = destPoint(B1, sideBearing,       expand1);
    const h0 = Math.tan(toRad(slopeDeg)) * d0;
    const h1 = Math.tan(toRad(slopeDeg)) * d1;
    const height = Math.max(h0, h1);
    const poly = [
      [left0[0],  left0[1]],
      [right0[0], right0[1]],
      [right1[0], right1[1]],
      [left1[0],  left1[1]],
      [left0[0],  left0[1]]
    ];
    bands.push({
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [poly] },
      properties: { _base: 0, _height: height, _color: color }
    });
  }
  return bands;
}
function generateWedgeBands(exp, slopeDeg, color, centroid) {
  const baseWidth = 3500;
  const wedgeLength = 85;
  const bands = [];
  const centerStart = midpoint(exp.expandedA, exp.expandedB);
  const sideCenterBearing = exp.sideBearing;
  const outward = outwardNormalBearingForExpanded(exp, centroid);
  const nSeg = 5;
  const segLen = wedgeLength / nSeg;
  const angleWidthRad = 300;
  for (let i=0;i<nSeg;i++){
    const d0 = i * segLen;
    const d1 = (i+1) * segLen;
    const c0 = destPoint(centerStart, outward, d0);
    const c1 = destPoint(centerStart, outward, d1);
    const half0 = (baseWidth/2) + d0 * Math.tan(angleWidthRad);
    const half1 = (baseWidth/2) + d1 * Math.tan(angleWidthRad);
    const left0  = destPoint(c0, sideCenterBearing + 180, half0);
    const right0 = destPoint(c0, sideCenterBearing,       half0);
    const left1  = destPoint(c1, sideCenterBearing + 180, half1);
    const right1 = destPoint(c1, sideCenterBearing,       half1);
    const h0 = Math.tan(toRad(slopeDeg)) * d0;
    const h1 = Math.tan(toRad(slopeDeg)) * d1;
    const topH = Math.max(h0, h1);
    const poly = [
      [left0[0],  left0[1]],
      [right0[0], right0[1]],
      [right1[0], right1[1]],
      [left1[0],  left1[1]],
      [left0[0],  left0[1]]
    ];
    bands.push({
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [ poly ] },
      properties: { _base: 0, _height: topH, _color: color }
    });
  }
  return bands;
}
function buildConicalCapsule(centerA, centerB) {
  const bands = [];
  const segments = 96;
  const nRings = 50;
  const radialStep = (conicalOuterRadius - innerHorizRadius) / nRings;
  const heightStep = conicalHeight / (conicalOuterRadius - innerHorizRadius);
  for (let ring = 0; ring < nRings; ring++) {
    const r0 = innerHorizRadius + ring * radialStep;
    const r1 = innerHorizRadius + (ring + 1) * radialStep;
    const h0 = innerHorizHeight + (r0 - innerHorizRadius) * heightStep;
    const h1 = innerHorizHeight + (r1 - innerHorizRadius) * heightStep;
    const ring0 = makeCapsuleRing(centerA, centerB, r0, segments);
    const ring1 = makeCapsuleRing(centerA, centerB, r1, segments);
    for (let i = 0; i < ring0.length; i++) {
      const next = (i + 1) % ring0.length;
      const p1 = ring0[i];
      const p2 = ring0[next];
      const p3 = ring1[next];
      const p4 = ring1[i];
      bands.push({
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [[p1, p2, p3, p4, p1]]
        },
        properties: {
          _base: h0,
          _height: h1,
          _color: "#ff9900"
        }
      });
    }
  }
  return bands;
}
function makeCapsuleRing(centerA, centerB, radius, segments = 96) {
  const pts = [];
  const br = bearing(centerA, centerB);
  const br180 = br + 180;
  for (let i = 0; i <= segments / 2; i++) {
    const ang = br + 90 - (i * 180) / (segments / 2);
    pts.push(destPoint(centerB, ang, radius));
  }
  for (let i = 0; i <= segments / 2; i++) {
    const ang = br180 + 90 - (i * 180) / (segments / 2);
    pts.push(destPoint(centerA, ang, radius));
  }
  return pts;
}function makeCircle(center, radiusM, segments = 180) {
  const pts = [];
  for (let i = 0; i <= segments; i++) {
    const ang = (i / segments) * 360;   // 0 → 360°
    pts.push(destPoint(center, ang, radiusM));
  }
  return pts;
}
const circle15000 = makeCircle(runwayCenter, 15000);
function buildIHS(centerA, centerB) {
  const pts = makeCapsuleRing(centerA, centerB, innerHorizRadius, 180);
  
  return [{
    type: "Feature",
    geometry: { type: "Polygon", coordinates: [pts] },
    properties: {
      _base: innerHorizHeight,
      _height: innerHorizHeight,
      _color: "#87CEEB"   
    }
  }];
}
function buildOHS_Donut(centerA, centerB, runwayCenter) {
  const outerRadius = 15000;  
  const innerRadius = conicalOuterRadius;
  const outerRing = makeCircle(runwayCenter, outerRadius, 360);
  let innerRing = makeCapsuleRing(centerA, centerB, innerRadius, 180);
  innerRing = innerRing.reverse();
  return [{
    type: "Feature",
    geometry: {
      type: "Polygon",
      coordinates: [
        outerRing,
        innerRing 
      ]
    },
    properties: {
      _base: innerHorizHeight + conicalHeight, 
      _height: innerHorizHeight + conicalHeight,
      _color: "#ADD8E6" 
    }
  }];
}
function processFeatures() {
  const approachSide = { a: A_ext, b: D_ext };
  const takeoffSide  = { a: B_ext, b: C_ext };
  const centerA = midpoint(A, D);
  const centerB = midpoint(C, B);
  const radius1 = 600;
  const radius2 = 700;
  const semicircleSamples = 64;
  const sideDC = { a: D_ext, b: C_ext }; 
  const sideAB = { a: A_ext, b: B_ext }; 
  const expDC = expandSideEndpoints(sideDC);
  const expAB = expandSideEndpoints(sideAB);
  const expApp  = expandSideEndpoints(approachSide);
  const expTake = expandSideEndpoints(takeoffSide);
  const centroidRect = (pts => { 
    let sx=0, sy=0; 
    for (const p of pts){ sx+=p[0]; sy+=p[1]; } 
    return [sx/pts.length, sy/pts.length];
  })([A,B,C,D]);
  const approachBands = generateWedgeBandsForExpanded(expApp, 3, "#ff6600", centroidRect);
  const takeoffBands  = generateWedgeBandsForExpanded(expTake, 3, "#ff6600", centroidRect);
  const dcBands       = generateWedgeBands(expDC, 22, "#00ccff", centroidRect);
  const abBands       = generateWedgeBands(expAB, 22, "#00ccff", centroidRect);
  const expandedLineApp = {
    type: "Feature",
    geometry: { type: "LineString", coordinates: [ expApp.expandedA, expApp.expandedB ] },
    properties: {}
  };
  const expandedLineTake = {
    type: "Feature",
    geometry: { type: "LineString", coordinates: [ expTake.expandedA, expTake.expandedB ] },
    properties: {}
  };
const extRect = makeOuterRunwayRect(A, B, C, D);
  return {
    expApp,
    expTake,
    approachBandsFC: { type: "FeatureCollection", features: approachBands },
    takeoffBandsFC:  { type: "FeatureCollection", features: takeoffBands },
    dcBandsFC:        { type: "FeatureCollection", features: dcBands },
    abBandsFC:        { type: "FeatureCollection", features: abBands },
    expandedLineApp,
    expandedLineTake,
  };
}
let rotating = false;
let rotationSpeed = 0.1;
ml = new maplibregl.Map({
  container: "map",
  style: {
    version: 8,
    sources: {
      esri: {
        type: "raster",
        tiles: [
          "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
        ],
        tileSize: 256
      }
    },
    layers: [
      { id:"esri", type:"raster", source:"esri" }
    ]
  },
  center: [77.104, 28.562],
  zoom: 15,
  minZoom: 9,
  maxZoom: 18,
  pitch: 55,
  bearing: 0,
  interactive: true,
  dragRotate: true,
  touchZoomRotate: true,
  renderWorldCopies: true
});
function rotateMap() {
  if (!rotating) return;
  ml.setBearing(ml.getBearing() + rotationSpeed);
  requestAnimationFrame(rotateMap);
} 
ml.getContainer().addEventListener('click', () => {
  rotating = !rotating;
  if (rotating) rotateMap();
});
ml.on("load", () => {
  proc = processFeatures();
  const bluePolygon = {
    type: "FeatureCollection",
    features: [{
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [rectCoords] },
      properties: { _height: 1, _base: 0, _color: "#0066ff" }
    }]
  };
  ml.addSource("rect-src", { type: "geojson", data: bluePolygon });
  ml.addLayer({
    id: "rect-3d",
    type: "fill-extrusion",
    source: "rect-src",
    paint: {
      "fill-extrusion-height": ["get","_height"],
      "fill-extrusion-base": ["get","_base"],
      "fill-extrusion-color": ["get","_color"],
      "fill-extrusion-opacity": 0.85
    }
  });
ml.addSource("outer-rect-src", {
  type: "geojson",
  data: {
    type: "FeatureCollection",
    features: [{
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [ outerRect ] },
      properties: { _height: 1, _base: 0, _color: "#00ff00" }
    }]
  }
});
ml.addLayer({
  id: "outer-rect-3d",
  type: "fill-extrusion",
  source: "outer-rect-src",
  paint: {
    "fill-extrusion-height": 1,
    "fill-extrusion-base": 0,
    "fill-extrusion-color": "#00ff00",
    "fill-extrusion-opacity": 0.4
  }
});
ml.addSource("dc-src", {
    type: "geojson",
    data: proc.dcBandsFC
});
ml.addLayer({
    id: "dc-3d",
    type: "fill-extrusion",
    source: "dc-src",
    paint: {
      "fill-extrusion-height": ["get","_height"],
      "fill-extrusion-base": ["get","_base"],
      "fill-extrusion-color": ["get","_color"],
      "fill-extrusion-opacity": 0.65
    }
});
ml.addSource("ab-src", {
    type: "geojson",
    data: proc.abBandsFC
});
ml.addLayer({
    id: "ab-3d",
    type: "fill-extrusion",
    source: "ab-src",
    paint: {
      "fill-extrusion-height": ["get","_height"],
      "fill-extrusion-base": ["get","_base"],
      "fill-extrusion-color": ["get","_color"],
      "fill-extrusion-opacity": 0.65
    }
});
ml.addSource("conical-src", {
  type: "geojson",
  data: { type: "FeatureCollection", features: conicalCapsule }
});
ml.addLayer({
  id: "conical-3d",
  type: "fill-extrusion",
  source: "conical-src",
  paint: {
    "fill-extrusion-height": ["get","_height"],
    "fill-extrusion-base": ["get","_base"],
    "fill-extrusion-color": ["get","_color"],
    "fill-extrusion-opacity": 1.0
  }
});
ml.addSource("circle15k-src", {
  type: "geojson",
  data: {
    type: "FeatureCollection",
    features: [{
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [circle15000] },
      properties: { _height: 1, _base: 0, _color: "#ff00ff" }
    }]
  }
});
ml.addLayer({
  id: "circle15k-3d",
  type: "fill-extrusion",
  source: "circle15k-src",
  paint: {
    "fill-extrusion-height": 1,
    "fill-extrusion-base": 0,
    "fill-extrusion-color": "#ff00ff",
    "fill-extrusion-opacity": 0.3
  }
});
const ihs = buildIHS(centerA, centerB);
ml.addSource("ihs-src", {
  type: "geojson",
  data: { type: "FeatureCollection", features: ihs }
});
ml.addLayer({
  id: "ihs-3d",
  type: "fill-extrusion",
  source: "ihs-src",
  paint: {
    "fill-extrusion-height": ["get","_height"],
    "fill-extrusion-base": ["get","_base"],
    "fill-extrusion-color": ["get","_color"],
    "fill-extrusion-opacity": 0.5
  }
});
const ohs = buildOHS_Donut(centerA, centerB, runwayCenter);
ml.addSource("ohs-src", {
  type: "geojson",
  data: { type: "FeatureCollection", features: ohs }
});
ml.addLayer({
  id: "ohs-3d",
  type: "fill-extrusion",
  source: "ohs-src",
  paint: {
    "fill-extrusion-height": ["get","_height"],
    "fill-extrusion-base": ["get","_base"],
    "fill-extrusion-color": ["get","_color"],
    "fill-extrusion-opacity": 0.4
  }
});
  ml.addSource("approach-src", { type: "geojson", data: proc.approachBandsFC });
  ml.addLayer({ id: "approach-3d", type: "fill-extrusion", source: "approach-src", paint: { "fill-extrusion-height":["get","_height"], "fill-extrusion-base":["get","_base"], "fill-extrusion-color":["get","_color"], "fill-extrusion-opacity":0.65 } });
  ml.addSource("takeoff-src", { type: "geojson", data: proc.takeoffBandsFC });
  ml.addLayer({ id: "takeoff-3d", type: "fill-extrusion", source: "takeoff-src", paint: { "fill-extrusion-height":["get","_height"], "fill-extrusion-base":["get","_base"], "fill-extrusion-color":["get","_color"], "fill-extrusion-opacity":0.65 } });
  ml.addSource("expanded-lines-src", { type: "geojson", data: { type: "FeatureCollection", features: [proc.expandedLineApp, proc.expandedLineTake] } });
  ml.addLayer({ id: "expanded-lines", type: "line", source: "expanded-lines-src", paint: { "line-color": "#000000", "line-width": 2 } });
  const mapping = [
    { checkboxId: "t_rect", layerIds: ["rect-3d"] },
    { checkboxId: "t_app",  layerIds: ["approach-3d", "expanded-lines"] },
    { checkboxId: "t_dc", layerIds: ["dc-3d"] },
    { checkboxId: "t_ab", layerIds: ["ab-3d"] },
    { checkboxId: "t_take", layerIds: ["takeoff-3d",  "expanded-lines"] },
    { checkboxId: "t_conical", layerIds: ["conical-3d"] },
    { checkboxId: "t_circle15k", layerIds: ["circle15k-3d"] },
    { checkboxId: "t_ihs", layerIds: ["ihs-3d"] },
    { checkboxId: "t_ohs", layerIds: ["ohs-3d"] },
  ];
  mapping.forEach(m => {
    const cb = document.getElementById(m.checkboxId);
    const vis = cb && cb.checked ? "visible" : "none";
    m.layerIds.forEach(id => { if (ml.getLayer(id)) ml.setLayoutProperty(id, "visibility", vis); });
    if (cb) cb.addEventListener("change", () => {
      const v = cb.checked ? "visible" : "none";
      m.layerIds.forEach(id => { if (ml.getLayer(id)) ml.setLayoutProperty(id, "visibility", v); });
    });
  });
  const cbApp = document.getElementById("t_app");
  const cbTake = document.getElementById("t_take");
  function updateExpandedLinesVisibility(){
    const visible = (cbApp && cbApp.checked) || (cbTake && cbTake.checked) ? "visible" : "none";
    if (ml.getLayer("expanded-lines")) ml.setLayoutProperty("expanded-lines", "visibility", visible);
  }
  if (cbApp) cbApp.addEventListener("change", updateExpandedLinesVisibility);
  if (cbTake) cbTake.addEventListener("change", updateExpandedLinesVisibility);
  updateExpandedLinesVisibility();
});
function pointInPoly(point, vs) {
  if (!vs || vs.length === 0) return false;
  let x = point[0], y = point[1];
  let inside = false;
  for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
    let xi = vs[i][0], yi = vs[i][1];
    let xj = vs[j][0], yj = vs[j][1];
    let intersect = ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / (yj - yi + 0.0) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}
function featureCentroid(feat) {
  const coords = feat.geometry && feat.geometry.coordinates && feat.geometry.coordinates[0];
  if (!coords || coords.length === 0) return [0,0];
  let x=0, y=0, n=0;
  coords.forEach(p => { x+=p[0]; y+=p[1]; n++; });
  return [x/n, y/n];
}
function polygonFromBands(bandsFC) {
  if (!bandsFC || !bandsFC.features) return [];
  return bandsFC.features.map(f => f.geometry.coordinates[0]);
}
function distancePointToLine(pt, lineAB) {
  const A = lineAB[0], B = lineAB[1];
  const dAB = distance(A, B);
  if (dAB === 0) return distance(pt, A);
  const d1 = distance(pt, A);
  const d2 = distance(pt, B);
  const s = (dAB + d1 + d2) / 2;
  let area = 0;
  const inner = Math.max(s * (s - dAB) * (s - d1) * (s - d2), 0);
  area = Math.sqrt(inner);
  const h = (2 * area) / (dAB || 1);
  return h;
}
async function renderBuildings() {
  if (!buildingsData || !proc || !ml) return;
  const tan2 = Math.tan(toRad(2));  // slope 2°
  const rectPoly = rectCoords;
  const approachBands = proc.approachBandsFC;
  const takeoffBands = proc.takeoffBandsFC;
  const approachLine = [proc.expApp.expandedA, proc.expApp.expandedB];
  const takeoffLine  = [proc.expTake.expandedA, proc.expTake.expandedB];
  const features = [];
  const approachRings = polygonFromBands(approachBands);
  const takeoffRings  = polygonFromBands(takeoffBands);
  buildingsData.features.forEach(f => {
    const meanH = Number(f.properties?.mean_h) || 0;
    const ctr = featureCentroid(f);
    const thresholds = [];
    if (pointInPoly(ctr, rectPoly)) thresholds.push(1);
    for (const ring of approachRings) {
      if (pointInPoly(ctr, ring)) {
        const d = distancePointToLine(ctr, approachLine);
        thresholds.push(1 + tan2 * d);
        break;
      }
    }
    for (const ring of takeoffRings) {
      if (pointInPoly(ctr, ring)) {
        const d = distancePointToLine(ctr, takeoffLine);
        thresholds.push(1 + tan2 * d);
        break;
      }
    }
    if (thresholds.length === 0) {
      const outF = JSON.parse(JSON.stringify(f));
      outF.properties._height = meanH;
      outF.properties._base = 0;
      outF.properties._color = "#0066ff";
      features.push(outF);
      return;
    }
    const finalT = Math.min(...thresholds);
    if (meanH <= finalT) {
      const bf = JSON.parse(JSON.stringify(f));
      bf.properties._height = meanH;
      bf.properties._base = 0;
      bf.properties._color = "#0066ff";
      features.push(bf);
    } else {
      const bottom = JSON.parse(JSON.stringify(f));
      bottom.properties._height = finalT;
      bottom.properties._base = 0;
      bottom.properties._color = "#0066ff";
      features.push(bottom);

      const top = JSON.parse(JSON.stringify(f));
      top.properties._height = meanH;
      top.properties._base = finalT;
      top.properties._color = "red";
      features.push(top);
    }
  });
  const stacked = { type: "FeatureCollection", features };
  if (ml.getSource("bld")) {
    ml.getSource("bld").setData(stacked);
  } else {
    ml.addSource("bld", { type: "geojson", data: stacked });
    ml.addLayer({
      id: "bld-3d",
      type: "fill-extrusion",
      source: "bld",
      paint: {
        "fill-extrusion-height": ["get", "_height"],
        "fill-extrusion-base": ["get", "_base"],
        "fill-extrusion-color": ["get", "_color"],
        "fill-extrusion-opacity": 0.85
      }
    });
    ml.on("click", "bld-3d", e => {
      const p = e.features[0].properties || {};
      const mean = p.mean_h || "N/A";
      const median = p.median_h || "N/A";
      const mode = p.mode_h || "N/A";
      new maplibregl.Popup()
        .setLngLat(e.lngLat)
        .setHTML(`<b>Building Height Details</b><br>Mean Height: ${mean} m<br>Median Height: ${median} m<br>Mode Height: ${mode} m`)
        .addTo(ml);
    });
  }
}
const toggleJSON = document.getElementById("toggleJSON");
toggleJSON.addEventListener("change", async () => {
  if (!ml || !proc) return;
  if (toggleJSON.checked) {
    try {
      buildingsData = await fetch("actual1.geojson").then(r => r.json());
    } catch (err) {
      console.warn("Could not load actual1.geojson:", err);
      buildingsData = { type: "FeatureCollection", features: [] };
    }
    renderBuildings();
    if (ml.getLayer("bld-3d")) ml.setLayoutProperty("bld-3d", "visibility", "visible");
  } else {
    if (ml.getLayer("bld-3d")) ml.setLayoutProperty("bld-3d", "visibility", "none");
  }
});
["t_rect","t_app","t_take"].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener("change", () => {
    if (toggleJSON.checked) renderBuildings();
  });
});
</script>
</body>
</html>