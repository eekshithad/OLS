<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>3D Buildings + Capsules/Wedges (fixed)</title>
  <link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
  <style>
    body { margin:0; padding:0; font-family: Arial, Helvetica, sans-serif; }
    #map { height: 100vh; width: 100vw; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 9999;
      background: white;
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 0 5px #333;
      max-width: 420px;
    }
    #controls button, #controls label { display: inline-block; margin: 4px 6px 4px 0; cursor: pointer; vertical-align: middle; }
    #toggles { margin-top: 6px; display:flex; flex-wrap:wrap; gap:6px; }
    .toggle-label { font-size:13px; }
  </style>
</head>
<body>
<div id="controls">
  <label class="toggle-label">
    <input type="checkbox" id="toggleJSON"> Load geojson
  </label>
  <div id="toggles">
    <label class="toggle-label"><input type="checkbox" id="t_rect" checked> Rectangle</label>
    <label class="toggle-label"><input type="checkbox" id="t_e1" checked> Contour 1</label>
    <label class="toggle-label"><input type="checkbox" id="t_e2" checked> Contour 2</label>
    <label class="toggle-label"><input type="checkbox" id="t_app" checked> Approach </label>
    <label class="toggle-label"><input type="checkbox" id="t_take" checked> Takeoff </label>
    <label><input type="checkbox" id="t_dc" checked> DC</label>
    <label><input type="checkbox" id="t_ab" checked> AB</label>
  </div>
</div>
<div id="map"></div>
<script>
const R = 6371000;
const toRad = d => d * Math.PI/180;
const toDeg = r => r * 180/Math.PI;
function distance(a,b){
  const Ï†1 = toRad(a[1]), Ï†2 = toRad(b[1]);
  const Î”Ï† = toRad(b[1]-a[1]), Î”Î» = toRad(b[0]-a[0]);
  const aa = Math.sin(Î”Ï†/2)**2 + Math.cos(Ï†1)*Math.cos(Ï†2)*Math.sin(Î”Î»/2)**2;
  const c = 2*Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa));
  return R*c;
}
function bearing(a,b){
  const Ï†1 = toRad(a[1]), Ï†2 = toRad(b[1]);
  const Î»1 = toRad(a[0]), Î»2 = toRad(b[0]);
  const y = Math.sin(Î»2-Î»1) * Math.cos(Ï†2);
  const x = Math.cos(Ï†1)*Math.sin(Ï†2) - Math.sin(Ï†1)*Math.cos(Ï†2)*Math.cos(Î»2-Î»1);
  return (toDeg(Math.atan2(y,x)) + 360) % 360;
}
function midpoint(a,b){ return [(a[0]+b[0])/2, (a[1]+b[1])/2]; }
function destPoint([lon, lat], bearingDeg, distanceM){
  const Ï†1 = toRad(lat);
  const Î»1 = toRad(lon);
  const Î¸ = toRad(bearingDeg);
  const Î´ = distanceM / R;
  const Ï†2 = Math.asin(Math.sin(Ï†1)*Math.cos(Î´) + Math.cos(Ï†1)*Math.sin(Î´)*Math.cos(Î¸));
  const Î»2 = Î»1 + Math.atan2(Math.sin(Î¸)*Math.sin(Î´)*Math.cos(Ï†1), Math.cos(Î´)-Math.sin(Ï†1)*Math.sin(Ï†2));
  return [toDeg(Î»2), toDeg(Ï†2)];
}
const A = [77.08500, 28.56760];
const B = [77.12270, 28.55880];
const C = [77.12260, 28.55800];
const D = [77.08490, 28.56680];
const rectCoords = [A, B, C, D, A];
const { A_ext, B_ext, C_ext, D_ext } = makeOuterRunwayRect(A, B, C, D);
const outerRect = [A_ext, B_ext, C_ext, D_ext, A_ext];
let ml = null;               // maplibre map instance
let proc = null;             // result of processFeatures() (computed once)
let buildingsData = null;    // geojson loaded
let bldSourceAdded = false;  // tracks whether 'bld' source added
function offsetPoint(pt, bearingDeg, distM) {
  return destPoint(pt, bearingDeg, distM);
}
function makeOuterRunwayRect(A, B, C, D, offsetAB_CD = 140, offsetBC_AD = 60) {
  const centroid = [
    (A[0] + B[0] + C[0] + D[0]) / 4,
    (A[1] + B[1] + C[1] + D[1]) / 4
  ];
  const brAB = bearing(A, B);
  const brBC = bearing(B, C);
  const brCD = bearing(C, D);
  const brDA = bearing(D, A);
  let nAB = (brAB + 90) % 360;
  let nBC = (brBC + 90) % 360;
  let nCD = (brCD + 90) % 360;
  let nDA = (brDA + 90) % 360;
  nAB = correctNormal(nAB, centroid, midpoint(A, B));
  nBC = correctNormal(nBC, centroid, midpoint(B, C));
  nCD = correctNormal(nCD, centroid, midpoint(C, D));
  nDA = correctNormal(nDA, centroid, midpoint(D, A));
  const A_ext = destPoint(
    destPoint(A, nDA, offsetBC_AD),
    nAB, offsetAB_CD
  );
  const B_ext = destPoint(
    destPoint(B, nAB, offsetAB_CD),
    nBC, offsetBC_AD
  );
  const C_ext = destPoint(
    destPoint(C, nBC, offsetBC_AD),
    nCD, offsetAB_CD
  );
  const D_ext = destPoint(
    destPoint(D, nCD, offsetAB_CD),
    nDA, offsetBC_AD
  );
  return { A_ext, B_ext, C_ext, D_ext };
}
function makeEllipseAroundExtendedRect({ A_ext, B_ext, C_ext, D_ext }, scale = 0.1, segments = 2) {

  // Center of extended rectangle
  const cx = (A_ext[0] + B_ext[0] + C_ext[0] + D_ext[0]) / 4;
  const cy = (A_ext[1] + B_ext[1] + C_ext[1] + D_ext[1]) / 4;

  // Major axis = AB length
  const major = distance(A_ext, B_ext) * scale;

  // Minor axis = BC length
  const minor = distance(B_ext, C_ext) * scale;

  const a = major / 2;  // semi-major
  const b = minor / 2;  // semi-minor

  // ellipse rotation = bearing of AB
  const theta = toRad(bearing(A_ext, B_ext));

  const coords = [];

  for (let i = 0; i <= segments; i++) {
    const t = (i / segments) * 2 * Math.PI;

    // parametric ellipse
    const x =
      cx + a * Math.cos(t) * Math.cos(theta) -
      b * Math.sin(t) * Math.sin(theta);

    const y =
      cy + a * Math.cos(t) * Math.sin(theta) +
      b * Math.sin(t) * Math.cos(theta);

    coords.push([x, y]);
  }

  return {
    type: "Feature",
    geometry: { type: "Polygon", coordinates: [coords] },
    properties: {
      name: "ellipse",
      _base: 0,
      _height: 0,
      _color: "BLACK"
    }
  };
}
const extRect = makeOuterRunwayRect(A, B, C, D);
const ellipseFeature = makeEllipseAroundExtendedRect(extRect);

function correctNormal(outward, centroid, midpoint) {
  const dirToCenter = bearing(midpoint, centroid);
  const diff = Math.abs(((outward - dirToCenter + 540) % 360) - 180);
  return diff > 90 ? outward : (outward + 180) % 360;
}
function makeCapsuleCoords(centerA, centerB, radius = 200, semicircleSamples = 64){
  const mainBr = bearing(centerA, centerB);
  const leftBr = (mainBr - 90 + 360) % 360;
  const rightBr = (mainBr + 90) % 360;
  const coords = [];
  const A_left = destPoint(centerA, leftBr, radius);
  const A_right = destPoint(centerA, rightBr, radius);
  const B_left = destPoint(centerB, leftBr, radius);
  const B_right = destPoint(centerB, rightBr, radius);
  coords.push(A_left);
  coords.push(B_left);
  for (let i = 0; i <= semicircleSamples; i++){
    const frac = i / semicircleSamples;
    const ang = (mainBr - 90) + frac * 180;
    coords.push(destPoint(centerB, ang, radius));
  }
  coords.push(B_right);
  coords.push(A_right);
  for (let i = 0; i <= semicircleSamples; i++){
    const frac = i / semicircleSamples;
    const ang = (mainBr + 90) + frac * 180;
    coords.push(destPoint(centerA, ang, radius));
  }
  coords.push(coords[0]);
  return coords;
}
const defaults = { bandCount: 360, wedgeLength: 3700, angleWidthDeg: 3 };
function expandSideEndpoints(side) {
  const sb = bearing(side.a, side.b);
  const expandedA = destPoint(side.a, sb + 180, 5);
  const expandedB = destPoint(side.b, sb, 5);
  return { expandedA, expandedB, sideBearing: sb };
}
function outwardNormalBearingForExpanded(expanded, centroid) {
  const centerLineStart = midpoint(expanded.expandedA, expanded.expandedB);
  const nR = (expanded.sideBearing + 90) % 360;
  const nL = (expanded.sideBearing + 270) % 360;
  const candR = destPoint(centerLineStart, nR, 10);
  const candL = destPoint(centerLineStart, nL, 10);
  const dR = distance(centroid, candR);
  const dL = distance(centroid, candL);
  return dR > dL ? nR : nL;
}
function generateWedgeBandsForExpanded(exp, slopeDeg, color, centroid) {
  const baseWidth = distance(exp.expandedA, exp.expandedB);
  const bands = [];
  const sideBearing = bearing(exp.expandedA, exp.expandedB);
  const outward = outwardNormalBearingForExpanded(exp, centroid);
  const nSeg = defaults.bandCount;
  const segLen = defaults.wedgeLength / nSeg;
  const angleWidthRad = toRad(defaults.angleWidthDeg);
  for (let i = 0; i < nSeg; i++) {
    const d0 = i * segLen;
    const d1 = (i + 1) * segLen;
    const A0 = destPoint(exp.expandedA, outward, d0);
    const B0 = destPoint(exp.expandedB, outward, d0);
    const A1 = destPoint(exp.expandedA, outward, d1);
    const B1 = destPoint(exp.expandedB, outward, d1);
    const expand0 = d0 * Math.tan(angleWidthRad);
    const expand1 = d1 * Math.tan(angleWidthRad);
    const left0  = destPoint(A0, sideBearing + 180, expand0);
    const right0 = destPoint(B0, sideBearing,       expand0);
    const left1  = destPoint(A1, sideBearing + 180, expand1);
    const right1 = destPoint(B1, sideBearing,       expand1);
    const h0 = Math.tan(toRad(slopeDeg)) * d0;
    const h1 = Math.tan(toRad(slopeDeg)) * d1;
    const height = Math.max(h0, h1);
    const poly = [
      [left0[0],  left0[1]],
      [right0[0], right0[1]],
      [right1[0], right1[1]],
      [left1[0],  left1[1]],
      [left0[0],  left0[1]]
    ];
    bands.push({
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [poly] },
      properties: { _base: 0, _height: height, _color: color }
    });
  }
  return bands;
}
function generateWedgeBands(exp, slopeDeg, color, centroid) {
  const baseWidth = 3500;
  const wedgeLength = 85;
  const bands = [];
  const centerStart = midpoint(exp.expandedA, exp.expandedB);
  const sideCenterBearing = exp.sideBearing;
  const outward = outwardNormalBearingForExpanded(exp, centroid);
  const nSeg = 5;
  const segLen = wedgeLength / nSeg;
  const angleWidthRad = 300;
  for (let i=0;i<nSeg;i++){
    const d0 = i * segLen;
    const d1 = (i+1) * segLen;
    const c0 = destPoint(centerStart, outward, d0);
    const c1 = destPoint(centerStart, outward, d1);
    const half0 = (baseWidth/2) + d0 * Math.tan(angleWidthRad);
    const half1 = (baseWidth/2) + d1 * Math.tan(angleWidthRad);
    const left0  = destPoint(c0, sideCenterBearing + 180, half0);
    const right0 = destPoint(c0, sideCenterBearing,       half0);
    const left1  = destPoint(c1, sideCenterBearing + 180, half1);
    const right1 = destPoint(c1, sideCenterBearing,       half1);
    const h0 = Math.tan(toRad(slopeDeg)) * d0;
    const h1 = Math.tan(toRad(slopeDeg)) * d1;
    const topH = Math.max(h0, h1);
    const poly = [
      [left0[0],  left0[1]],
      [right0[0], right0[1]],
      [right1[0], right1[1]],
      [left1[0],  left1[1]],
      [left0[0],  left0[1]]
    ];
    bands.push({
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [ poly ] },
      properties: { _base: 0, _height: topH, _color: color }
    });
  }
  return bands;
}function processFeatures() {

  // --- existing -------------------------------------------
  const approachSide = { a: A_ext, b: D_ext }; // AD
  const takeoffSide  = { a: B_ext, b: C_ext }; // BC

  const centerA = midpoint(A, D);
  const centerB = midpoint(C, B);

  const radius1 = 600;
  const radius2 = 700;
  const semicircleSamples = 64;

  const c1Coords = makeCapsuleCoords(centerA, centerB, radius1, semicircleSamples);
  const c2Coords = makeCapsuleCoords(centerA, centerB, radius2, semicircleSamples);

  const sideDC = { a: D_ext, b: C_ext }; 
  const sideAB = { a: A_ext, b: B_ext }; 

  const expDC = expandSideEndpoints(sideDC);
  const expAB = expandSideEndpoints(sideAB);

  const capsule1Feature = {
    type: "Feature",
    geometry: { type: "Polygon", coordinates: [ c1Coords ] },
    properties: { _base: 0, _height: 10, _color: "#FFB6C1" }
  };

  const capsule2Feature = {
    type: "Feature",
    geometry: { type: "Polygon", coordinates: [ c2Coords ] },
    properties: { _base: 10, _height: 20, _color: "#F4C2C2" }
  };

  const expApp  = expandSideEndpoints(approachSide);
  const expTake = expandSideEndpoints(takeoffSide);

  const centroidRect = (pts => { 
    let sx=0, sy=0; 
    for (const p of pts){ sx+=p[0]; sy+=p[1]; } 
    return [sx/pts.length, sy/pts.length];
  })([A,B,C,D]);

  const approachBands = generateWedgeBandsForExpanded(expApp, 2, "#ff6600", centroidRect);
  const takeoffBands  = generateWedgeBandsForExpanded(expTake, 2, "#ff6600", centroidRect);
  const dcBands       = generateWedgeBands(expDC, 2, "#00ccff", centroidRect);
  const abBands       = generateWedgeBands(expAB, 2, "#00ccff", centroidRect);

  const expandedLineApp = {
    type: "Feature",
    geometry: { type: "LineString", coordinates: [ expApp.expandedA, expApp.expandedB ] },
    properties: {}
  };

  const expandedLineTake = {
    type: "Feature",
    geometry: { type: "LineString", coordinates: [ expTake.expandedA, expTake.expandedB ] },
    properties: {}
  };

  // ----------------------------------------------------------
  // ðŸŸ¦ NEW PART â€” Create ellipse from EXTENDED RECTANGLE
  // ----------------------------------------------------------

  const extRect = makeOuterRunwayRect(A, B, C, D);

  const ellipseFeature = makeEllipseAroundExtendedRect(extRect);

  const ellipseFC = {
    type: "FeatureCollection",
    features: [ellipseFeature]
  };

  // ----------------------------------------------------------
  // FINAL RETURN
  // ----------------------------------------------------------

  return {
    capsule1Feature,
    capsule2Feature,

    c1Coords,
    c2Coords,

    expApp,
    expTake,

    approachBandsFC: { type: "FeatureCollection", features: approachBands },
    takeoffBandsFC:  { type: "FeatureCollection", features: takeoffBands },
    dcBandsFC:        { type: "FeatureCollection", features: dcBands },
    abBandsFC:        { type: "FeatureCollection", features: abBands },

    expandedLineApp,
    expandedLineTake,

    // NEW
    ellipseFC
  };
}

ml = new maplibregl.Map({
  container: "map",
  style: {
    version: 8,
    sources: {
      esri: {
        type: "raster",
        tiles: ["https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"],
        tileSize: 256
      }
    },
    layers: [{ id:"esri", type:"raster", source:"esri" }]
  },
  center: [77.104, 28.562],
  zoom: 15,
  minZoom: 9,
  maxZoom: 18,
  pitch: 55,
  bearing: -20,
  interactive: true
});
ml.on("load", () => {
  proc = processFeatures();
  const bluePolygon = {
    type: "FeatureCollection",
    features: [{
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [rectCoords] },
      properties: { _height: 1, _base: 0, _color: "#0066ff" }
    }]
  };
  ml.addSource("rect-src", { type: "geojson", data: bluePolygon });
  ml.addLayer({
    id: "rect-3d",
    type: "fill-extrusion",
    source: "rect-src",
    paint: {
      "fill-extrusion-height": ["get","_height"],
      "fill-extrusion-base": ["get","_base"],
      "fill-extrusion-color": ["get","_color"],
      "fill-extrusion-opacity": 0.85
    }
  });
ml.addSource("outer-rect-src", {
  type: "geojson",
  data: {
    type: "FeatureCollection",
    features: [{
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [ outerRect ] },
      properties: { _height: 1, _base: 0, _color: "#00ff00" }
    }]
  }
});
ml.addLayer({
  id: "outer-rect-3d",
  type: "fill-extrusion",
  source: "outer-rect-src",
  paint: {
    "fill-extrusion-height": 1,
    "fill-extrusion-base": 0,
    "fill-extrusion-color": "#00ff00",
    "fill-extrusion-opacity": 0.4
  }
});
ml.addSource("dc-src", {
    type: "geojson",
    data: proc.dcBandsFC
});
ml.addLayer({
    id: "dc-3d",
    type: "fill-extrusion",
    source: "dc-src",
    paint: {
      "fill-extrusion-height": ["get","_height"],
      "fill-extrusion-base": ["get","_base"],
      "fill-extrusion-color": ["get","_color"],
      "fill-extrusion-opacity": 0.65
    }
});
ml.addSource("ab-src", {
    type: "geojson",
    data: proc.abBandsFC
});
ml.addLayer({
    id: "ab-3d",
    type: "fill-extrusion",
    source: "ab-src",
    paint: {
      "fill-extrusion-height": ["get","_height"],
      "fill-extrusion-base": ["get","_base"],
      "fill-extrusion-color": ["get","_color"],
      "fill-extrusion-opacity": 0.65
    }
});
ml.addSource("ellipseSource", {
  type: "geojson",
  data: proc.ellipseFC
});

ml.addLayer({
  id: "ellipseLayer",
  type: "fill-extrusion",
  source: "ellipseSource",
  paint: {
    "fill-extrusion-color": "#88ccff",
    "fill-extrusion-height": 0,
    "fill-extrusion-opacity": 0.6
  }
});

  ml.addSource("capsule1-src", { type: "geojson", data: { type: "FeatureCollection", features: [proc.capsule1Feature] } });
  ml.addLayer({ id: "capsule1-3d", type: "fill-extrusion", source: "capsule1-src", paint: { "fill-extrusion-height":["get","_height"], "fill-extrusion-base":["get","_base"], "fill-extrusion-color":["get","_color"], "fill-extrusion-opacity":0.85 } });
  ml.addSource("capsule2-src", { type: "geojson", data: { type: "FeatureCollection", features: [proc.capsule2Feature] } });
  ml.addLayer({ id: "capsule2-3d", type: "fill-extrusion", source: "capsule2-src", paint: { "fill-extrusion-height":["get","_height"], "fill-extrusion-base":["get","_base"], "fill-extrusion-color":["get","_color"], "fill-extrusion-opacity":0.85 } });
  ml.addSource("approach-src", { type: "geojson", data: proc.approachBandsFC });
  ml.addLayer({ id: "approach-3d", type: "fill-extrusion", source: "approach-src", paint: { "fill-extrusion-height":["get","_height"], "fill-extrusion-base":["get","_base"], "fill-extrusion-color":["get","_color"], "fill-extrusion-opacity":0.65 } });
  ml.addSource("takeoff-src", { type: "geojson", data: proc.takeoffBandsFC });
  ml.addLayer({ id: "takeoff-3d", type: "fill-extrusion", source: "takeoff-src", paint: { "fill-extrusion-height":["get","_height"], "fill-extrusion-base":["get","_base"], "fill-extrusion-color":["get","_color"], "fill-extrusion-opacity":0.65 } });
  ml.addSource("expanded-lines-src", { type: "geojson", data: { type: "FeatureCollection", features: [proc.expandedLineApp, proc.expandedLineTake] } });
  ml.addLayer({ id: "expanded-lines", type: "line", source: "expanded-lines-src", paint: { "line-color": "#000000", "line-width": 2 } });
  const mapping = [
    { checkboxId: "t_rect", layerIds: ["rect-3d"] },
    { checkboxId: "t_e1",   layerIds: ["capsule1-3d"] },
    { checkboxId: "t_e2",   layerIds: ["capsule2-3d"] },
    { checkboxId: "t_app",  layerIds: ["approach-3d", "expanded-lines"] },
    { checkboxId: "t_dc", layerIds: ["dc-3d"] },
    { checkboxId: "t_ab", layerIds: ["ab-3d"] },
    { checkboxId: "t_take", layerIds: ["takeoff-3d",  "expanded-lines"] }
  ];
  mapping.forEach(m => {
    const cb = document.getElementById(m.checkboxId);
    const vis = cb && cb.checked ? "visible" : "none";
    m.layerIds.forEach(id => { if (ml.getLayer(id)) ml.setLayoutProperty(id, "visibility", vis); });
    if (cb) cb.addEventListener("change", () => {
      const v = cb.checked ? "visible" : "none";
      m.layerIds.forEach(id => { if (ml.getLayer(id)) ml.setLayoutProperty(id, "visibility", v); });
    });
  });
  const cbApp = document.getElementById("t_app");
  const cbTake = document.getElementById("t_take");
  function updateExpandedLinesVisibility(){
    const visible = (cbApp && cbApp.checked) || (cbTake && cbTake.checked) ? "visible" : "none";
    if (ml.getLayer("expanded-lines")) ml.setLayoutProperty("expanded-lines", "visibility", visible);
  }
  if (cbApp) cbApp.addEventListener("change", updateExpandedLinesVisibility);
  if (cbTake) cbTake.addEventListener("change", updateExpandedLinesVisibility);
  updateExpandedLinesVisibility();
});
function pointInPoly(point, vs) {
  if (!vs || vs.length === 0) return false;
  let x = point[0], y = point[1];
  let inside = false;
  for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
    let xi = vs[i][0], yi = vs[i][1];
    let xj = vs[j][0], yj = vs[j][1];
    let intersect = ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / (yj - yi + 0.0) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}
function featureCentroid(feat) {
  const coords = feat.geometry && feat.geometry.coordinates && feat.geometry.coordinates[0];
  if (!coords || coords.length === 0) return [0,0];
  let x=0, y=0, n=0;
  coords.forEach(p => { x+=p[0]; y+=p[1]; n++; });
  return [x/n, y/n];
}
function polygonFromBands(bandsFC) {
  if (!bandsFC || !bandsFC.features) return [];
  return bandsFC.features.map(f => f.geometry.coordinates[0]);
}
function distancePointToLine(pt, lineAB) {
  const A = lineAB[0], B = lineAB[1];
  const dAB = distance(A, B);
  if (dAB === 0) return distance(pt, A);
  const d1 = distance(pt, A);
  const d2 = distance(pt, B);
  const s = (dAB + d1 + d2) / 2;
  let area = 0;
  const inner = Math.max(s * (s - dAB) * (s - d1) * (s - d2), 0);
  area = Math.sqrt(inner);
  const h = (2 * area) / (dAB || 1);
  return h;
}
async function renderBuildings() {
  if (!buildingsData || !proc || !ml) return;
  const tan2 = Math.tan(toRad(2));  // slope 2Â°
  const rectPoly = rectCoords;
  const approachBands = proc.approachBandsFC;
  const takeoffBands = proc.takeoffBandsFC;
  const approachLine = [proc.expApp.expandedA, proc.expApp.expandedB];
  const takeoffLine  = [proc.expTake.expandedA, proc.expTake.expandedB];
  const features = [];
  const approachRings = polygonFromBands(approachBands);
  const takeoffRings  = polygonFromBands(takeoffBands);
  const c1ring = proc.capsule1Feature.geometry.coordinates[0];
  const c2ring = proc.capsule2Feature.geometry.coordinates[0];
  buildingsData.features.forEach(f => {
    const meanH = Number(f.properties?.mean_h) || 0;
    const ctr = featureCentroid(f);
    const thresholds = [];
    if (pointInPoly(ctr, rectPoly)) thresholds.push(1);
    if (pointInPoly(ctr, c1ring)) thresholds.push(10);
    if (pointInPoly(ctr, c2ring)) thresholds.push(20);
    for (const ring of approachRings) {
      if (pointInPoly(ctr, ring)) {
        const d = distancePointToLine(ctr, approachLine);
        thresholds.push(1 + tan2 * d);
        break;
      }
    }
    for (const ring of takeoffRings) {
      if (pointInPoly(ctr, ring)) {
        const d = distancePointToLine(ctr, takeoffLine);
        thresholds.push(1 + tan2 * d);
        break;
      }
    }
    if (thresholds.length === 0) {
      const outF = JSON.parse(JSON.stringify(f));
      outF.properties._height = meanH;
      outF.properties._base = 0;
      outF.properties._color = "#0066ff";
      features.push(outF);
      return;
    }
    const finalT = Math.min(...thresholds);
    if (meanH <= finalT) {
      const bf = JSON.parse(JSON.stringify(f));
      bf.properties._height = meanH;
      bf.properties._base = 0;
      bf.properties._color = "#0066ff";
      features.push(bf);
    } else {
      const bottom = JSON.parse(JSON.stringify(f));
      bottom.properties._height = finalT;
      bottom.properties._base = 0;
      bottom.properties._color = "#0066ff";
      features.push(bottom);

      const top = JSON.parse(JSON.stringify(f));
      top.properties._height = meanH;
      top.properties._base = finalT;
      top.properties._color = "red";
      features.push(top);
    }
  });
  const stacked = { type: "FeatureCollection", features };
  if (ml.getSource("bld")) {
    ml.getSource("bld").setData(stacked);
  } else {
    ml.addSource("bld", { type: "geojson", data: stacked });
    ml.addLayer({
      id: "bld-3d",
      type: "fill-extrusion",
      source: "bld",
      paint: {
        "fill-extrusion-height": ["get", "_height"],
        "fill-extrusion-base": ["get", "_base"],
        "fill-extrusion-color": ["get", "_color"],
        "fill-extrusion-opacity": 0.85
      }
    });
    ml.on("click", "bld-3d", e => {
      const p = e.features[0].properties || {};
      const mean = p.mean_h || "N/A";
      const median = p.median_h || "N/A";
      const mode = p.mode_h || "N/A";
      new maplibregl.Popup()
        .setLngLat(e.lngLat)
        .setHTML(`<b>Building Height Details</b><br>Mean Height: ${mean} m<br>Median Height: ${median} m<br>Mode Height: ${mode} m`)
        .addTo(ml);
    });
  }
}
const toggleJSON = document.getElementById("toggleJSON");
toggleJSON.addEventListener("change", async () => {
  if (!ml || !proc) return;
  if (toggleJSON.checked) {
    try {
      buildingsData = await fetch("actual1.geojson").then(r => r.json());
    } catch (err) {
      console.warn("Could not load actual1.geojson:", err);
      buildingsData = { type: "FeatureCollection", features: [] };
    }
    renderBuildings();
    if (ml.getLayer("bld-3d")) ml.setLayoutProperty("bld-3d", "visibility", "visible");
  } else {
    if (ml.getLayer("bld-3d")) ml.setLayoutProperty("bld-3d", "visibility", "none");
  }
});
["t_rect","t_e1","t_e2","t_app","t_take"].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener("change", () => {
    if (toggleJSON.checked) renderBuildings();
  });
});
</script>
</body>
</html>